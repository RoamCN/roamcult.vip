
# Backlinks
## [Ethereum Whitepaper](Ethereum Whitepaper.md)
- The concept of decentralized digital currency, as well as alternative applications like property registries, has been around for decades. The anonymous e-cash protocols of the 1980s and the 1990s, mostly reliant on a cryptographic primitive known as [Chaumian blinding](Chaumian blinding.md), provided a currency with a high degree of [privacy](privacy.md), but the protocols largely failed to gain traction because of their reliance on a centralized intermediary. In 1998, [Wei Dai](Wei Dai.md)'s [b-money](b-money.md) became the first proposal to introduce the idea of creating money through solving computational puzzles as well as [decentralized](decentralized.md) [consensus](consensus.md), but the proposal was scant on details as to how decentralized consensus could actually be implemented. In [2005](2005.md), [Hal Finney](Hal Finney.md) introduced a concept of [reusable proofs of work](http://nakamotoinstitute.org/finney/rpow/), a system which uses ideas from b-money together with [Adam Back](Adam Back.md)'s computationally difficult [Hashcash](Hashcash.md) puzzles to create a concept for a [cryptocurrency](cryptocurrency.md), but once again fell short of the ideal by relying on trusted computing as a backend. In [2009](2009.md), a decentralized currency was for the first time implemented in practice by [Satoshi Nakamoto](Satoshi Nakamoto.md), combining established primitives for managing ownership through [public key cryptography](public key cryptography.md) with a consensus algorithm for keeping track of who owns coins, known as "[proof of work](proof of work.md)"

- The mechanism behind [proof of work](proof of work.md)

- The one validity condition present in the above list that is not found in other systems is the requirement for "[proof of work](proof of work.md)"

- An important scalability feature of Bitcoin is that the block is stored in a multi-level data structure. The "[hash](hash.md)" of a block is actually only the hash of the block header, a roughly 200-byte piece of data that contains the timestamp, nonce, previous block hash and the root hash of a data structure called the [Merkle tree](Merkle tree.md) storing all transactions in the block. A Merkle tree is a type of binary tree, composed of a set of nodes with a large number of leaf nodes at the bottom of the tree containing the underlying data, a set of intermediate nodes where each node is the hash of its two children, and finally a single root node, also formed from the hash of its two children, representing the "top" of the tree. The purpose of the Merkle tree is to allow the data in a block to be delivered piecemeal: a node can download only the header of a block from one source, the small part of the tree relevant to them from another source, and still be assured that all of the data is correct. The reason why this works is that hashes propagate upward: if a malicious user attempts to swap in a fake transaction into the bottom of a Merkle tree, this change will cause a change in the node above, and then a change in the node above that, finally changing the root of the tree and therefore the hash of the block, causing the protocol to register it as a completely different block (almost certainly with an invalid [proof of work](proof of work.md))

